{"system": "You are the INTL compiler for Python Fastapi. Given an INTL block, produce idiomatic, production-ready Python Fastapi code. Wrap output in INTL:BEGIN / INTL:END sentinels with the correct block ID.", "prompt": "FUNCTION register_webhook [id=f0001]\n  INTENT       \"register a new webhook endpoint for a user and store configuration\"\n  PRECONDITION user_id.length > 0\n  PRECONDITION url.length > 0\n  PRECONDITION events IS NOT EMPTY\n  POSTCONDITION result.webhook_id IS NOT NULL\n  READS        users_table\n  MUTATES      webhooks_table\n  OBSERVABLE\n\n  user = QUERY users_table WHERE id == user_id LIMIT 1\n  IF user IS NULL THEN FAIL NotFoundError(\"user_not_found\")\n  IF NOT user.is_active THEN FAIL PermissionError(\"user_inactive\")\n  webhook_id = generate_uuid()\n  secret = generate_secret()\n  PERSIST webhooks_table (id: webhook_id, user_id: user_id, url: url, events: events, secret: secret, created_at: now())\n  RETURN WebhookRegistration(webhook_id: webhook_id, secret: secret)\nEND FUNCTION register_webhook [id=f0001]", "completion": "# ═══ INTL:BEGIN [id=f0001] register_webhook ═══\nimport logging\nimport uuid\nfrom datetime import datetime\nfrom typing import List\n\nlogger = logging.getLogger(__name__)\n\nasync def register_webhook(user_id: str, url: str, events: List[str]) -> WebhookRegistration:\n    assert len(user_id) > 0, \"user_id must not be empty\"\n    assert len(url) > 0, \"url must not be empty\"\n    assert len(events) > 0, \"events list must not be empty\"\n    \n    user = await db.query(users_table).filter(id=user_id).first()\n    if user is None:\n        raise NotFoundError(\"user_not_found\")\n    if not user.is_active:\n        raise PermissionError(\"user_inactive\")\n    \n    webhook_id = str(uuid.uuid4())\n    secret = str(uuid.uuid4())\n    \n    await db.insert(\n        webhooks_table,\n        id=webhook_id,\n        user_id=user_id,\n        url=url,\n        events=events,\n        secret=secret,\n        created_at=datetime.utcnow()\n    )\n    \n    logger.info(\"register_webhook: webhook_id=%s, user_id=%s, events=%s\", webhook_id, user_id, events)\n    \n    result = WebhookRegistration(webhook_id=webhook_id, secret=secret)\n    assert result.webhook_id is not None\n    return result\n# ═══ INTL:END   [id=f0001] register_webhook ═══", "metadata": {"category": "A", "adapter": "python_fastapi", "construct": "QUERY", "idx": 1}}
{"system": "You are the INTL compiler for Python Fastapi in PATCH mode. Apply the PATCH block to the existing code with minimal diff. Wrap output in INTL:BEGIN / INTL:END sentinels.", "prompt": "INTL:BEGIN\n@app.get(\"/analytics/events\")\nasync def get_events(user_id: str, limit: int = 100):\n    try:\n        events = db.query(f\"SELECT * FROM events WHERE user_id = {user_id} LIMIT {limit}\")\n        return {\"status\": \"success\", \"data\": events}\n    except Exception as e:\n        return {\"status\": \"error\", \"message\": str(e)}\nINTL:END\n\nPATCH f0024 [target=f0024]\n  INTENT \"add structured error handling and logging for analytics failures\"\n  ADD BEFORE: logger.error(f\"Analytics query failed for user {user_id}: {e}\", exc_info=True)\n  MODIFY: return statement in except block to include error_code and timestamp\nEND PATCH f0024", "completion": "INTL:BEGIN\n@app.get(\"/analytics/events\")\nasync def get_events(user_id: str, limit: int = 100):\n    try:\n        events = db.query(f\"SELECT * FROM events WHERE user_id = {user_id} LIMIT {limit}\")\n        return {\"status\": \"success\", \"data\": events}\n    except Exception as e:\n        logger.error(f\"Analytics query failed for user {user_id}: {e}\", exc_info=True)\n        return {\"status\": \"error\", \"message\": str(e), \"error_code\": \"ANALYTICS_QUERY_FAILED\", \"timestamp\": datetime.utcnow().isoformat()}\nINTL:END", "metadata": {"category": "B", "adapter": "python_fastapi", "construct": "FAIL", "idx": 24}}
{"system": "You are the INTL compiler for Python Fastapi. Given an INTL block, produce idiomatic, production-ready Python Fastapi code. Wrap output in INTL:BEGIN / INTL:END sentinels with the correct block ID.", "prompt": "FUNCTION list_active_coupons [id=f0000]\n  INTENT       \"retrieve paginated list of active coupons with discount filtering\"\n  PRECONDITION page >= 1\n  PRECONDITION page_size > 0\n  PRECONDITION page_size <= 100\n  PRECONDITION min_discount >= 0\n  POSTCONDITION result.total >= 0\n  POSTCONDITION result.items IS NOT NULL\n  READS        coupons_table\n  MUTATES      coupon_access_logs_table\n  OBSERVABLE\n\n  PAGINATE coupons_table WHERE status == \"active\" AND discount_percent >= min_discount\n    ORDER BY created_at DESC\n    LIMIT page_size\n    OFFSET (page - 1) * page_size\n\n  items = PAGINATE_RESULT\n  total = PAGINATE_COUNT\n  \n  FOR EACH coupon IN items DO\n    PERSIST coupon_access_logs_table (coupon_id: coupon.id, accessed_at: now(), user_ip: request.ip)\n  END FOR\n  \n  RETURN CouponPage(items: items, total: total, page: page, page_size: page_size)\nEND FUNCTION list_active_coupons [id=f0000]", "completion": "# ═══ INTL:BEGIN [id=f0000] list_active_coupons ═══\nimport logging\nfrom datetime import datetime\nfrom typing import List\n\nlogger = logging.getLogger(__name__)\n\nasync def list_active_coupons(\n    page: int,\n    page_size: int,\n    min_discount: float,\n    request\n) -> CouponPage:\n    assert page >= 1, \"page must be >= 1\"\n    assert page_size > 0, \"page_size must be > 0\"\n    assert page_size <= 100, \"page_size must be <= 100\"\n    assert min_discount >= 0, \"min_discount must be >= 0\"\n    \n    offset = (page - 1) * page_size\n    \n    items = await db.query(coupons_table).filter(\n        status=\"active\",\n        discount_percent__gte=min_discount\n    ).order_by(\"-created_at\").limit(page_size).offset(offset).all()\n    \n    total = await db.query(coupons_table).filter(\n        status=\"active\",\n        discount_percent__gte=min_discount\n    ).count()\n    \n    for coupon in items:\n        await db.insert(\n            coupon_access_logs_table,\n            coupon_id=coupon.id,\n            accessed_at=datetime.utcnow(),\n            user_ip=request.client.host\n        )\n    \n    logger.info(\"list_active_coupons: page=%d, page_size=%d, total=%d\", page, page_size, total)\n    \n    result = CouponPage(\n        items=items,\n        total=total,\n        page=page,\n        page_size=page_size\n    )\n    \n    assert result.total >= 0\n    assert result.items is not None\n    \n    return result\n# ═══ INTL:END   [id=f0000] list_active_coupons ═══", "metadata": {"category": "A", "adapter": "python_fastapi", "construct": "PAGINATE", "idx": 0}}
{"system": "You are the INTL compiler for Python Fastapi. Given an INTL block, produce idiomatic, production-ready Python Fastapi code. Wrap output in INTL:BEGIN / INTL:END sentinels with the correct block ID.", "prompt": "FUNCTION log_audit_event [id=f0008]\n  INTENT       \"record user action in audit log with timestamp and metadata\"\n  PRECONDITION user_id.length > 0\n  PRECONDITION action.length > 0\n  PRECONDITION severity IN [\"INFO\", \"WARNING\", \"CRITICAL\"]\n  POSTCONDITION result.event_id IS NOT NULL\n  READS        users_table\n  MUTATES      audit_logs_table\n  OBSERVABLE\n\n  user = QUERY users_table WHERE id == user_id LIMIT 1\n  IF user IS NULL THEN FAIL NotFoundError(\"user_not_found\")\n  IF severity NOT IN [\"INFO\", \"WARNING\", \"CRITICAL\"] THEN FAIL ValidationError(\"invalid_severity\")\n  event_id = generate_uuid()\n  PERSIST audit_logs_table (event_id: event_id, user_id: user_id, action: action, severity: severity, timestamp: now(), ip_address: ip_address, user_agent: user_agent)\n  RETURN AuditEvent(event_id: event_id, user_id: user_id, action: action, severity: severity)\nEND FUNCTION log_audit_event [id=f0008]", "completion": "# ═══ INTL:BEGIN [id=f0008] log_audit_event ═══\nimport logging\nimport uuid\nfrom datetime import datetime\nfrom typing import Literal\n\nlogger = logging.getLogger(__name__)\n\nasync def log_audit_event(\n    user_id: str,\n    action: str,\n    severity: Literal[\"INFO\", \"WARNING\", \"CRITICAL\"],\n    ip_address: str,\n    user_agent: str\n) -> AuditEvent:\n    assert len(user_id) > 0, \"user_id must not be empty\"\n    assert len(action) > 0, \"action must not be empty\"\n    assert severity in [\"INFO\", \"WARNING\", \"CRITICAL\"], \"severity must be one of INFO, WARNING, CRITICAL\"\n    \n    user = await db.query(users_table).filter(id=user_id).first()\n    if user is None:\n        raise NotFoundError(\"user_not_found\")\n    \n    if severity not in [\"INFO\", \"WARNING\", \"CRITICAL\"]:\n        raise ValidationError(\"invalid_severity\")\n    \n    event_id = str(uuid.uuid4())\n    await db.insert(\n        audit_logs_table,\n        event_id=event_id,\n        user_id=user_id,\n        action=action,\n        severity=severity,\n        timestamp=datetime.utcnow(),\n        ip_address=ip_address,\n        user_agent=user_agent\n    )\n    \n    logger.info(\"audit_event: event_id=%s user_id=%s action=%s severity=%s\", event_id, user_id, action, severity)\n    \n    result = AuditEvent(event_id=event_id, user_id=user_id, action=action, severity=severity)\n    assert result.event_id is not None\n    return result\n# ═══ INTL:END   [id=f0008] log_audit_event ═══", "metadata": {"category": "A", "adapter": "python_fastapi", "construct": "PERSIST", "idx": 8}}
{"system": "You are the INTL compiler for Python Fastapi. Given an INTL block, produce idiomatic, production-ready Python Fastapi code. Wrap output in INTL:BEGIN / INTL:END sentinels with the correct block ID.", "prompt": "FUNCTION process_order [id=f0021]\n  INTENT       \"process order sequence: validate inventory, calculate pricing, reserve stock, and persist order\"\n  PRECONDITION order.items.length > 0\n  PRECONDITION order.customer_id.length > 0\n  PRECONDITION order.total_amount > 0\n  POSTCONDITION result.order_id IS NOT NULL\n  POSTCONDITION result.status == \"confirmed\"\n  READS        inventory_table, pricing_rules_table\n  MUTATES      orders_table, order_items_table, inventory_reserve_table\n  OBSERVABLE\n\n  SEQUENCE\n    STEP validate_stock\n      FOR EACH item IN order.items DO\n        stock = QUERY inventory_table WHERE product_id == item.product_id LIMIT 1\n        IF stock IS NULL THEN FAIL ValidationError(\"product_not_found\")\n        IF stock.available_quantity < item.quantity THEN FAIL ValidationError(\"insufficient_stock\")\n      END\n    \n    STEP calculate_pricing\n      total = 0\n      FOR EACH item IN order.items DO\n        rule = QUERY pricing_rules_table WHERE product_id == item.product_id LIMIT 1\n        price = IF rule IS NULL THEN item.base_price ELSE rule.adjusted_price\n        total = total + (price * item.quantity)\n      END\n      IF total != order.total_amount THEN FAIL ValidationError(\"price_mismatch\")\n    \n    STEP reserve_inventory\n      FOR EACH item IN order.items DO\n        PERSIST inventory_reserve_table (product_id: item.product_id, order_id: order.id, quantity: item.quantity)\n        UPDATE inventory_table SET available_quantity = available_quantity - item.quantity WHERE product_id == item.product_id\n      END\n    \n    STEP persist_order\n      order_record = (customer_id: order.customer_id, total_amount: order.total_amount, status: \"confirmed\", created_at: now())\n      PERSIST orders_table order_record\n      FOR EACH item IN order.items DO\n        PERSIST order_items_table (order_id: order_record.id, product_id: item.product_id, quantity: item.quantity)\n      END\n  END SEQUENCE\n\n  RETURN OrderConfirmation(order_id: order_record.id, status: \"confirmed\", total_amount: total)\nEND FUNCTION process_order [id=f0021]", "completion": "# ═══ INTL:BEGIN [id=f0021] process_order ═══\nimport logging\nfrom datetime import datetime\nfrom typing import List\n\nlogger = logging.getLogger(__name__)\n\nclass OrderItem:\n    product_id: str\n    quantity: int\n    base_price: float\n\nclass Order:\n    items: List[OrderItem]\n    customer_id: str\n    total_amount: float\n    id: str\n\nclass OrderConfirmation:\n    order_id: str\n    status: str\n    total_amount: float\n\nasync def process_order(order: Order) -> OrderConfirmation:\n    assert len(order.items) > 0, \"order items must not be empty\"\n    assert len(order.customer_id) > 0, \"customer_id must not be empty\"\n    assert order.total_amount > 0, \"total_amount must be greater than 0\"\n    \n    # STEP: validate_stock\n    for item in order.items:\n        stock = await db.query(inventory_table).filter(product_id=item.product_id).first()\n        if stock is None:\n            raise ValidationError(\"product_not_found\")\n        if stock.available_quantity < item.quantity:\n            raise ValidationError(\"insufficient_stock\")\n    \n    # STEP: calculate_pricing\n    total = 0\n    for item in order.items:\n        rule = await db.query(pricing_rules_table).filter(product_id=item.product_id).first()\n        price = rule.adjusted_price if rule is not None else item.base_price\n        total += price * item.quantity\n    \n    if total != order.total_amount:\n        raise ValidationError(\"price_mismatch\")\n    \n    # STEP: reserve_inventory\n    for item in order.items:\n        await db.insert(inventory_reserve_table, product_id=item.product_id, \n                       order_id=order.id, quantity=item.quantity)\n        await db.execute(\n            \"UPDATE inventory_table SET available_quantity = available_quantity - ? WHERE product_id = ?\",\n            (item.quantity, item.product_id)\n        )\n    \n    # STEP: persist_order\n    order_record = await db.insert(orders_table, customer_id=order.customer_id,\n                                    total_amount=order.total_amount, status=\"confirmed\",\n                                    created_at=datetime.utcnow())\n    \n    for item in order.items:\n        await db.insert(order_items_table, order_id=order_record.id,\n                       product_id=item.product_id, quantity=item.quantity)\n    \n    logger.info(\"process_order: order_id=%s customer_id=%s total_amount=%f\",\n                order_record.id, order.customer_id, total)\n    \n    result = OrderConfirmation(order_id=order_record.id, status=\"confirmed\", total_amount=total)\n    assert result.order_id is not None\n    assert result.status == \"confirmed\"\n    return result\n# ═══ INTL:END   [id=f0021] process_order ═══", "metadata": {"category": "A", "adapter": "python_fastapi", "construct": "SEQUENCE", "idx": 21}}
