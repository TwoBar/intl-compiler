# INTL — Intent Language
**Language Specification & Compiler Layer Requirements**
Version 0.1  |  February 2026  |  Confidential


| Status | Draft — Active Development |
| --- | --- |
| Languages | 24 target compilation targets |
| Compiler Strategy | 3B LoRA adapters + frontier escalation |
| Total Training Cost | ~$22 (Vast.ai RTX 4090) |


# Part 1 — Language Overview


## 1.1 Purpose and Design Philosophy

INTL (Intent Language) is a structured intermediate representation designed to be written by frontier AI models and compiled into idiomatic, production-ready code in any target language. It is not a general-purpose programming language. It is a precise, unambiguous specification of what code should do — completely decoupled from how any specific language implements it.
The core insight is that AI models are excellent at understanding intent and terrible at maintaining consistency across large codebases. INTL captures the intent explicitly, and small fine-tuned compiler models handle the mechanical translation to target language idioms.

### Design Principles

- Intent first — INTL describes what, not how. Implementation decisions belong to the compiler layer.
- Explicit over implicit — preconditions, postconditions, side effects, and observable behaviour are always declared.
- Target-agnostic — the same INTL block compiles to Python FastAPI, Java Spring, Rust Axum, or any other target without modification.
- Verifiable — every INTL construct maps deterministically to testable assertions in the compiled output.
- Patchable — INTL supports incremental edits via PATCH blocks, enabling surgical code updates without full recompilation.
- Escalation-aware — compilation failures route to frontier models automatically; INTL never bypasses the structured layer.


### What INTL Is Not

- Not a runtime language — INTL is never executed directly.
- Not a DSL for a single framework — it has no framework-specific syntax.
- Not a template system — outputs are generated by trained models, not string substitution.
- Not a configuration format — it expresses behaviour, not settings.

## 1.2 The Compilation Pipeline

An INTL block passes through four stages before becoming runnable code:
Stage 1 — Parse  →  Lark grammar tokenises and validates the INTL block into an AST.
Stage 2 — Index  →  Semantic index stores the AST node in SQLite with dependency graph and dirty flags.
Stage 3 — Compile  →  LoRA router selects the correct adapter and runs the 3B model to produce target code.
Stage 4 — Validate  →  Output is tested against POSTCONDITION assertions. Failures escalate to frontier.
Escalation means the frontier model receives the full INTL block and the failed compiled output. It never sees the original intent freeform — structure is always preserved.

## 1.3 File Structure

INTL source files use the .intl extension and follow this structure:
# intl source file
MODULE auth [id=m001]
  TARGET     "src/services/auth.py"
  PROFILE    python_fastapi
  NAMESPACE  "app.services.auth"
  REQUIRES   m002   # dependency on users module

FUNCTION login [id=f001]
  ...
END FUNCTION login [id=f001]

PIPELINE checkout [id=p001]
  ...
END PIPELINE checkout [id=p001]
Each file contains exactly one MODULE declaration followed by any number of FUNCTION, PIPELINE, and TYPE blocks. The MODULE id is globally unique within a project and drives the dependency graph.


# Part 2 — Language Specification


## 2.1 MODULE Declaration

Every INTL file begins with a MODULE block. It provides the compilation context for everything that follows.

| Field | Description |
| --- | --- |
| TARGET | Relative path to the output source file (e.g. src/services/auth.py) |
| PROFILE | Compilation target identifier — matches an adapter name (e.g. python_fastapi, java_spring) |
| NAMESPACE | Fully-qualified module/package path in the target language |
| REQUIRES | Space-separated list of module IDs this module depends on (drives dirty propagation) |
| VERSION | Semantic version string — optional, used for adapter compatibility checks |


MODULE users [id=m002]
  TARGET     "src/models/users.py"
  PROFILE    python_fastapi
  NAMESPACE  "app.models.users"
  VERSION    "1.0.0"

## 2.2 FUNCTION Block

FUNCTION is the primary unit of compilation. Each FUNCTION block compiles to a single function, method, or procedure in the target language.

### Required Fields


| Field | Description |
| --- | --- |
| INTENT | Natural language description of what the function does. One sentence. Used by the compiler as the primary signal. |
| PRECONDITION | Guard clause that must be true before the function executes. Multiple PRECONDITION lines allowed. Each compiles to an explicit guard in output. |
| POSTCONDITION | Assertion that must be true after successful execution. Compiles to assertions or return-type constraints. |


### Optional Fields


| Field | Description |
| --- | --- |
| READS | Table/collection the function reads from. Compiles to SELECT or equivalent. |
| MUTATES | Table/collection the function writes to. Compiles to INSERT/UPDATE/DELETE. |
| EMITS | Event name the function publishes. Compiles to event emit call. |
| OBSERVABLE | Flag — compiles to logging decorators/middleware wrapping the function. |
| CONFIDENCE | Float 0.0–1.0. Below 0.8, compiler wraps output in approximation markers. Triggers escalation review. |
| TIMEOUT | Duration string (e.g. 30s). Compiles to timeout wrapper or deadline context. |


FUNCTION login [id=f001]
  INTENT       "validate credentials and return a session token"
  PRECONDITION email.length > 0
  PRECONDITION password.length >= 8
  POSTCONDITION result.token IS NOT NULL
  POSTCONDITION result.expires_at > NOW()
  READS        users_table
  MUTATES      sessions_table
  OBSERVABLE
  CONFIDENCE   0.95

  user = QUERY users_table WHERE email == email LIMIT 1
  IF user IS NULL THEN FAIL AuthError("user_not_found")
  IF NOT verify_hash(password, user.password_hash) THEN FAIL AuthError("invalid_password")
  token = generate_token(user.id)
  PERSIST sessions_table INSERT (user_id: user.id, token: token, expires_at: NOW() + 24h)
  RETURN SessionToken(token: token, expires_at: NOW() + 24h)
END FUNCTION login [id=f001]

## 2.3 Core Constructs Reference

The following constructs form the full vocabulary of INTL function bodies. Every construct has a deterministic mapping in every target language adapter.

| Construct | Syntax | Category | Compiler Output |
| --- | --- | --- | --- |
| QUERY | QUERY table WHERE cond LIMIT n | Data | SELECT with WHERE clause |
| PERSIST INSERT | PERSIST table INSERT (fields) | Data | INSERT INTO / db.add() |
| PERSIST UPDATE | PERSIST table UPDATE (fields) WHERE cond | Data | UPDATE WHERE / db.update() |
| PERSIST DELETE | PERSIST table DELETE WHERE cond | Data | DELETE WHERE / db.delete() |
| CALL | CALL function(args) | Control | Synchronous function call |
| AWAIT | AWAIT CALL function(args) | Control | Async/await function call |
| IF / THEN / ELSE | IF cond THEN expr ELSE expr | Control | if/else block |
| FAIL | FAIL ErrorType(message) | Control | raise / throw / panic |
| RETURN | RETURN value | Control | return statement |
| SEQUENCE | SEQUENCE ... END SEQUENCE | Flow | Sequential execution block |
| PARALLEL | PARALLEL ... END PARALLEL | Flow | asyncio.gather / Promise.all / goroutines |
| FALLBACK | FALLBACK PRIMARY: ... FALLBACK: ... | Flow | try/except with retry |
| LOOP | LOOP items AS item DO ... END LOOP | Flow | for loop / map / each |
| EMIT | EMIT event_name(fields) | Event | Event publish call |
| SUBSCRIBE | SUBSCRIBE event_name DO ... | Event | Event handler registration |
| CACHE GET | CACHE GET key AS var | Cache | Cache read with miss handling |
| CACHE SET | CACHE SET key = value TTL duration | Cache | Cache write with TTL |
| TRANSACTION | TRANSACTION ... END TRANSACTION | Data | db.begin() / commit() / rollback() |
| VALIDATE | VALIDATE fields AGAINST schema | Guard | Schema validation call |
| PAGINATE | PAGINATE query PAGE n SIZE m | Data | OFFSET/LIMIT or cursor-based |
| AGGREGATE | AGGREGATE table BY field COMPUTE fn | Data | GROUP BY with aggregate function |
| TRANSFORM | TRANSFORM input USING fn | Data | Map/transform with function |
| LOCK | LOCK resource DO ... END LOCK | Concurrency | Mutex / advisory lock / SELECT FOR UPDATE |


## 2.4 PIPELINE Block

PIPELINE groups multiple operations into a named, testable workflow. Pipelines compile to orchestration functions that coordinate calls, handle fallbacks, and emit events.
PIPELINE process_order [id=p001]
  INTENT     "validate, charge, and confirm an order atomically"
  OBSERVABLE
  CONFIDENCE 0.88

  SEQUENCE
    validate = CALL validate_order(order)
    IF validate.status == "invalid" THEN FAIL OrderError(validate.reason)

    payment = FALLBACK
      PRIMARY:  CALL charge_payment(order.payment_method, order.total)
      FALLBACK: CALL charge_payment(order.backup_payment, order.total)
    END FALLBACK

    PARALLEL
      CALL update_inventory(order.items)
      CALL send_confirmation_email(order.user_email, order)
      EMIT order_confirmed(order_id: order.id)
    END PARALLEL
  END SEQUENCE

  RETURN OrderReceipt(order_id: order.id, payment_id: payment.id)
END PIPELINE process_order [id=p001]

## 2.5 TYPE Block

TYPE blocks define data shapes. They compile to dataclasses, Pydantic models, TypeScript interfaces, Java records, Rust structs, or equivalent in the target language.
TYPE SessionToken [id=t001]
  FIELD token      : String  NOT NULL
  FIELD user_id    : UUID    NOT NULL
  FIELD expires_at : DateTime NOT NULL
  FIELD created_at : DateTime DEFAULT NOW()
  CONSTRAINT expires_at > created_at
END TYPE SessionToken [id=t001]

| Primitive Types | Description |
| --- | --- |
| String | UTF-8 text. No length limit unless specified with String(n). |
| Int | 64-bit integer. |
| Float | 64-bit IEEE 754 float. |
| Bool | True/False. |
| UUID | RFC 4122 UUID. Compiles to native UUID type per language. |
| DateTime | ISO 8601 datetime with timezone. Compiles to datetime/Instant/etc. |
| Date | Calendar date without time. |
| Duration | Time duration (e.g. 24h, 30s, 5m). |
| Bytes | Raw byte sequence. |
| JSON | Untyped JSON value. Compiles to dict/Map/serde_json::Value. |
| T[] | List of T. e.g. String[] compiles to List[str] / string[] / Vec<String>. |
| T? | Optional T. Compiles to Optional[T] / T | null / Option<T>. |
| Map<K,V> | Key-value map. |


## 2.6 PATCH Block

PATCH is the incremental update mechanism. When a FUNCTION or PIPELINE already has compiled output, a PATCH block modifies only the specified section — the compiler produces a minimal diff, not a full recompilation.
PATCH FUNCTION login [id=f001]
  INTENT       "add suspended account check before password validation"
  INSERT PRECONDITION "user.account_status != 'suspended'"
  INSERT AFTER line WHERE intent MATCHES "user_not_found check"
  WITH
    IF user.account_status == "suspended"
      THEN FAIL AuthError("account_suspended")
END PATCH FUNCTION login [id=f001]
PATCH blocks are the hardest construct for compiler models to learn. They require the model to understand the existing compiled output and produce a minimal targeted edit. Training dataset must include 30% PATCH pairs.

## 2.7 Sentinel Comments

Every compiled output block is wrapped in sentinel comments that mark the INTL-managed region. These enable the semantic index to locate and update compiled blocks without full file parsing.
# ═══ INTL:BEGIN [id=f001] login ════════════════════════════
async def login(email: str, password: str, ...):
    ...
# ═══ INTL:END [id=f001] ═════════════════════════════════════
The sentinel format is identical across all target languages, adjusted only for comment syntax (# for Python, // for TypeScript/Java/Go/Rust/C#/C++, -- for SQL, /* */ for CSS).

| Language | Comment Style | BEGIN sentinel | END sentinel |
| --- | --- | --- | --- |
| Python | # | # ═══ INTL:BEGIN [id=X] name ═ | # ═══ INTL:END [id=X] ═ |
| TypeScript / JS | // | // ═══ INTL:BEGIN [id=X] name ═ | // ═══ INTL:END [id=X] ═ |
| Java / C# / Go | // | // ═══ INTL:BEGIN [id=X] name ═ | // ═══ INTL:END [id=X] ═ |
| Rust / C++ | // | // ═══ INTL:BEGIN [id=X] name ═ | // ═══ INTL:END [id=X] ═ |
| PHP | // | // ═══ INTL:BEGIN [id=X] name ═ | // ═══ INTL:END [id=X] ═ |
| Ruby | # | # ═══ INTL:BEGIN [id=X] name ═ | # ═══ INTL:END [id=X] ═ |
| Swift / Kotlin | // | // ═══ INTL:BEGIN [id=X] name ═ | // ═══ INTL:END [id=X] ═ |
| Dart | // | // ═══ INTL:BEGIN [id=X] name ═ | // ═══ INTL:END [id=X] ═ |
| SQL | -- | -- ═══ INTL:BEGIN [id=X] name ═ | -- ═══ INTL:END [id=X] ═ |
| HTML (Jinja/Blade) | {# #} | {# ═══ INTL:BEGIN [id=X] ═} | {# ═══ INTL:END [id=X] ═} |
| CSS | /* */ | /* ═══ INTL:BEGIN [id=X] ═*/ | /* ═══ INTL:END [id=X] ═*/ |



# Part 3 — Compiler Layer Requirements


## 3.1 Architecture Overview

The compiler layer consists of five components operating as a pipeline. Each component has a clear interface and can be replaced independently.

| Component | Responsibility |
| --- | --- |
| 1. Parser | Lark grammar validates INTL syntax and produces a typed AST. Rejects invalid INTL before any model call. |
| 2. Semantic Index | SQLite database storing AST nodes, dependency graph, dirty flags, and compiled output hashes. Source of truth for what needs recompilation. |
| 3. LoRA Router | O(1) lookup from (language, profile) → (adapter_name). No inference. Pure deterministic dispatch. |
| 4. Compiler Engine | vLLM or llama.cpp serving Qwen2.5-Coder-3B-Instruct with LoRA adapter hot-loaded. Produces compiled output. |
| 5. Validator | Runs compiled output against POSTCONDITION assertions and type checks. Triggers escalation on failure. |


## 3.2 Parser Requirements

The parser is the first line of defence. It must reject malformed INTL before wasting model compute.
- Grammar: Lark EBNF grammar covering all 24 constructs in §2.3.
- Output: Typed AST with node type, id, fields, body, and source location.
- Validation: All required fields present. IDs globally unique within project. PROFILE matches known adapter list.
- Error messages: Human-readable, pointing to line/column. Never swallowed silently.
- Performance: Parse a 500-line INTL file in under 50ms on Mac Apple Silicon.

## 3.3 Semantic Index Requirements


### Schema

-- modules table
CREATE TABLE modules (
  id          TEXT PRIMARY KEY,   -- e.g. m001
  file_path   TEXT NOT NULL,      -- source .intl file
  target_path TEXT NOT NULL,      -- compiled output file
  profile     TEXT NOT NULL,      -- adapter name
  namespace   TEXT NOT NULL,
  hash        TEXT NOT NULL,      -- SHA256 of INTL source
  compiled_at DATETIME
);

-- nodes table (functions, pipelines, types)
CREATE TABLE nodes (
  id          TEXT PRIMARY KEY,   -- e.g. f001
  module_id   TEXT REFERENCES modules(id),
  kind        TEXT NOT NULL,      -- FUNCTION | PIPELINE | TYPE | PATCH
  name        TEXT NOT NULL,
  intent      TEXT,
  body_hash   TEXT NOT NULL,      -- SHA256 of INTL body
  output_hash TEXT,               -- SHA256 of compiled output
  dirty       BOOLEAN DEFAULT 1,  -- needs recompilation
  confidence  REAL,
  compiled_at DATETIME
);

-- dependency edges
CREATE TABLE dependencies (
  from_module TEXT REFERENCES modules(id),
  to_module   TEXT REFERENCES modules(id),
  PRIMARY KEY (from_module, to_module)
);

### Dirty Propagation Rules

- A node is marked dirty when its INTL body hash changes.
- When a module is marked dirty, all modules that REQUIRE it are also marked dirty.
- A PATCH block marks only its target node dirty, not the whole module.
- Compilation clears the dirty flag and records output_hash and compiled_at.

## 3.4 LoRA Router Requirements

The router must be a pure lookup function with no side effects and no inference calls.
ADAPTER_MAP = {
  # (language, profile)        → adapter_name
  ('python',     'fastapi'):    'python_fastapi',
  ('python',     'django'):     'python_django',
  ('python',     'flask'):      'python_flask',
  ('typescript', 'express'):    'typescript_express',
  ('typescript', 'nextjs'):     'typescript_nextjs',
  ('javascript', 'vanilla'):    'javascript_vanilla',
  ('php',        'laravel'):    'php_laravel',
  ('php',        'vanilla'):    'php_vanilla',
  ('sql',        'postgresql'): 'sql_postgres',
  ('sql',        'mysql'):      'sql_mysql',
  ('sql',        'sqlite'):     'sql_sqlite',
  ('sql',        'tsql'):       'sql_tsql',
  ('html',       'jinja2'):     'html_jinja2',
  ('html',       'blade'):      'html_blade',
  ('css',        'tailwind'):   'css_tailwind',
  ('java',       'spring'):     'java_spring',
  ('csharp',     'dotnet'):     'csharp_dotnet',
  ('go',         'gin'):        'go_gin',
  ('ruby',       'rails'):      'ruby_rails',
  ('swift',      'ios'):        'swift_ios',
  ('kotlin',     'android'):    'kotlin_android',
  ('dart',       'flutter'):    'dart_flutter',
  ('rust',       'axum'):       'rust_axum',
  ('cpp',        'modern'):     'cpp_modern',
}

## 3.5 Compiler Engine Requirements


### Base Model


| Property | Value |
| --- | --- |
| Model | Qwen/Qwen2.5-Coder-3B-Instruct |
| Quantisation | 4-bit AWQ (inference) / 4-bit NF4 QLoRA (training) |
| Adapter format | LoRA — r=64, lora_alpha=128 |
| Inference backend | vLLM (Linux/server) or llama.cpp (Mac Metal) |
| Max sequence length | 2048 tokens |
| Temperature | 0.1 — near-deterministic for structured output |
| Number of adapters | 24 — one per language/profile combination |
| Hot adapters on Mac 24GB | All 24 simultaneously (~2.4GB total) |


### System Prompt (fixed for all adapters)

You are the INTL compiler for {LANGUAGE} {PROFILE}.
Translate the provided INTL block exactly into idiomatic {LANGUAGE}.
Output ONLY the {LANGUAGE} code. No explanation. No markdown fences.
Respect all PRECONDITIONS as guards. Map POSTCONDITIONS to assertions.
MUTATES become explicit db writes. OBSERVABLE becomes a logging decorator.
CONFIDENCE below 0.8 wraps output in an approximation marker.
Wrap all output in INTL sentinel comments using {COMMENT_STYLE}.

### Inference Performance Targets


| Hardware | tok/s (3B 4-bit) | Python fn compile | SQL query compile |
| --- | --- | --- | --- |
| Mac 24GB Unified (Metal) | ~85 | ~3s | ~1s |
| RTX 4090 24GB | ~180 | ~1.4s | ~0.5s |
| A100 SXM 80GB | ~280 | ~0.9s | ~0.3s |
| Vast.ai RTX 4090 | ~180 | ~1.4s | ~0.5s |


## 3.6 Validation and Escalation Requirements


### Validation Checks

- Sentinel comments present and correctly formatted.
- POSTCONDITION assertions present in output (at least as comments).
- Return type matches TYPE declaration if one exists.
- No placeholder text (TODO, FIXME, pass, unimplemented!()) in output.
- Syntax valid for target language (via tree-sitter parse).
- MUTATES blocks contain at least one write operation.
- OBSERVABLE functions contain logging calls.

### Escalation Package

When validation fails after the retry budget is exhausted, an ESCALATION package is sent to the frontier model. The package contains:
- The original INTL block (complete).
- The failed compiled output (complete).
- The failing validation check and error message.
- The target language and adapter name.
- The retry count and previous attempt outputs.
The frontier model always receives a structured ESCALATION package — never freeform text. This ensures escalated outputs are still wrapped in INTL sentinels and can be written back to the semantic index.

### Retry Budget


| Language Group | Retry Budget |
| --- | --- |
| SQL, HTML, CSS (low complexity) | 2 retries before escalation |
| Python, TypeScript, PHP, Go, Ruby (medium) | 3 retries before escalation |
| Java, C#, Swift, Kotlin, Dart (medium-high) | 3 retries before escalation |
| Rust, C++ (high complexity) | 4 retries before escalation |



# Part 4 — Target Language Requirements

Each language target has specific output requirements that training data must exemplify and compiler outputs must satisfy. These are the contracts between INTL constructs and target-language idioms.

## 4.1 Python (FastAPI / Django / Flask)


| INTL Construct | FastAPI output | Django output | Flask output |
| --- | --- | --- | --- |
| FUNCTION | async def fn(...) -> ReturnType: | def fn(request, ...) -> JsonResponse: | def fn()  # route handler |
| PRECONDITION | HTTPException(status_code=422, ...) | ValidationError / form.is_valid() | abort(422, ...) |
| QUERY | await db.execute(select(Model).where(...)) | Model.objects.filter(...) | Model.query.filter(...) |
| PERSIST INSERT | db.add(obj); await db.commit() | Model.objects.create(...) | db.session.add(obj); db.session.commit() |
| FAIL | raise HTTPException(status_code=X, detail=msg) | raise ValidationError / return error | abort(status_code, msg) |
| OBSERVABLE | @logger.info decorator + entry/exit logs | Django middleware or decorator | @app.before/after_request |
| PARALLEL | await asyncio.gather(...) | django-q async task group | concurrent.futures.ThreadPoolExecutor |
| FALLBACK | try/except with retry logic | try/except with retry logic | try/except with retry logic |
| TRANSACTION | async with db.begin(): | with transaction.atomic(): | with db.session.begin(): |


## 4.2 TypeScript / JavaScript


| INTL Construct | TypeScript / JavaScript output |
| --- | --- |
| FUNCTION | export async function fn(args: Types): Promise<ReturnType> |
| PRECONDITION | if (!condition) throw new Error(message) or Zod validation |
| QUERY | await prisma.table.findFirst({ where: ... }) or raw SQL |
| PERSIST INSERT | await prisma.table.create({ data: ... }) |
| FAIL | throw new CustomError(message) with status code |
| PARALLEL | await Promise.all([fn1(), fn2(), fn3()]) |
| TYPE | interface TypeName { field: Type } or Zod schema + type inference |
| OBSERVABLE | console.log / pino / winston with entry+exit logging |
| EMIT | eventEmitter.emit(eventName, payload) or EventBridge.putEvents(...) |


## 4.3 SQL Dialects


| INTL Construct | PostgreSQL | MySQL | SQLite / T-SQL |
| --- | --- | --- | --- |
| QUERY | SELECT ... FROM ... WHERE ... LIMIT n | SELECT ... LIMIT n | SELECT ... TOP n (T-SQL) / LIMIT (SQLite) |
| PERSIST INSERT | INSERT INTO ... RETURNING id | INSERT INTO ... (no RETURNING) | INSERT INTO ... (no RETURNING) |
| PERSIST UPDATE | UPDATE ... WHERE ... RETURNING * | UPDATE ... WHERE ... | UPDATE ... WHERE ... |
| TRANSACTION | BEGIN; ... COMMIT; ROLLBACK on error | START TRANSACTION; ... COMMIT; | BEGIN TRANSACTION; ... COMMIT; |
| AGGREGATE | GROUP BY ... HAVING ... | GROUP BY ... HAVING ... | GROUP BY ... HAVING ... |
| PAGINATE | LIMIT n OFFSET m | LIMIT n OFFSET m | OFFSET n ROWS FETCH NEXT m (T-SQL) / LIMIT (SQLite) |
| UUID type | UUID column / gen_random_uuid() | CHAR(36) / UUID() | TEXT (stored as string) |
| DateTime type | TIMESTAMPTZ | DATETIME | TEXT / INTEGER (Unix epoch for SQLite) |


## 4.4 Java Spring Boot


| INTL Construct | Java Spring Boot output |
| --- | --- |
| FUNCTION | @Service method: public ReturnType methodName(Args args) throws CustomException |
| PRECONDITION | @Valid annotation + manual if-check + throw new ResponseStatusException(400, ...) |
| QUERY | repository.findByField(value) or @Query("SELECT e FROM Entity e WHERE ...") |
| PERSIST INSERT | repository.save(entity) — Spring Data JPA convention |
| FAIL | throw new ResponseStatusException(HttpStatus.X, message) |
| OBSERVABLE | @Slf4j + log.info("method called", args) / @LogExecutionTime AOP |
| PARALLEL | CompletableFuture.allOf(f1, f2, f3).join() or @Async methods |
| TRANSACTION | @Transactional annotation on method |
| TYPE | @Data @Entity class TypeName { @Column fields... } |


## 4.5 Systems Languages (Rust / C++)

Rust and C++ have the highest escalation rates (~20%) due to ownership semantics, lifetime annotations, and template complexity. The 3B compiler handles ~80% of cases; frontier escalation covers the rest.

| INTL Construct | Rust Axum output |
| --- | --- |
| FUNCTION | pub async fn name(args: Args) -> Result<Json<Return>, AppError> |
| PRECONDITION | if !condition { return Err(AppError::Validation(msg)) } |
| QUERY | sqlx::query_as!(Type, "SELECT...", args).fetch_one(&pool).await? |
| PERSIST INSERT | sqlx::query!("INSERT INTO...", fields).execute(&pool).await? |
| FAIL | return Err(AppError::Custom { status: StatusCode::X, message: msg.into() }) |
| PARALLEL | tokio::join!(fut1, fut2, fut3) or tokio::task::spawn() |
| TRANSACTION | let mut tx = pool.begin().await?; ... tx.commit().await? |
| OBSERVABLE | tracing::info!("fn called", field = value) at entry and exit |
| TYPE | #[derive(Debug, Serialize, Deserialize)] struct TypeName { field: Type } |

Rust PRECONDITION guards use ? operator propagation — FAIL becomes return Err(...) not panic!(). Training data must exemplify the error propagation pattern consistently.

## 4.6 Mobile Targets (Swift / Kotlin / Dart)


| INTL Construct | Swift iOS / SwiftUI | Kotlin Android / Compose |
| --- | --- | --- |
| FUNCTION | func name(args: Types) async throws -> ReturnType | suspend fun name(args: Types): ReturnType |
| PRECONDITION | guard condition else { throw AppError.validation(msg) } | require(condition) { msg } |
| QUERY | try await supabase.from(table).select().eq(field, val).single() | repository.findByField(value) |
| FAIL | throw AppError.custom(message: msg) | throw AppException(msg, code) |
| PARALLEL | async let a = fn1(); async let b = fn2(); (try await a, try await b) | coroutineScope { async { fn1() }; async { fn2() } } |
| TYPE | struct TypeName: Codable { let field: Type } | data class TypeName(val field: Type) |
| OBSERVABLE | os_log / Logger().info() | Log.i(TAG, message) |



# Part 5 — Training Data Requirements


## 5.1 Dataset Format

All training pairs are stored as JSONL (one JSON object per line) with three fields: system, prompt, and completion.
{
  "system":     "You are the INTL compiler for Python FastAPI...",
  "prompt":     "FUNCTION login [id=f001]\n  INTENT...",
  "completion": "# ═══ INTL:BEGIN [id=f001] login ═══\nasync def login..."
}
For MLX training (Mac) and Unsloth training (Vast.ai), the system+prompt+completion are concatenated into a single text field with EOS tokens between segments.

## 5.2 Training Pair Categories


| Category | % of Dataset | Description |
| --- | --- | --- |
| A — Fresh compilation | ~60% | INTL block → target output from scratch. Covers all construct combinations and complexity levels. |
| B — PATCH compilation | ~30% | Existing compiled block + PATCH → minimally modified output. Most valuable and hardest category. |
| C — Error correction | ~10% | INTL block + failed output + error message → corrected output. Teaches self-repair. |


## 5.3 Training Pair Counts by Adapter


| Adapter | Phase | Pairs | Est. Vast.ai Cost |
| --- | --- | --- | --- |
| python_fastapi | 0 | 3,000 | $0.13 |
| sql_postgres | 0 | 1,500 | $0.06 |
| python_django | 1 | 2,000 | $0.09 |
| python_flask | 1 | 1,500 | $0.07 |
| typescript_express | 1 | 2,500 | $0.11 |
| sql_mysql | 1 | 800 | $0.03 |
| typescript_nextjs | 2 | 2,000 | $0.09 |
| php_laravel | 2 | 2,500 | $0.11 |
| php_vanilla | 2 | 1,500 | $0.07 |
| javascript_vanilla | 2 | 1,500 | $0.07 |
| html_jinja2 | 2 | 1,000 | $0.04 |
| html_blade | 2 | 800 | $0.03 |
| css_tailwind | 2 | 600 | $0.03 |
| java_spring | 3 | 2,500 | $0.11 |
| csharp_dotnet | 3 | 2,000 | $0.09 |
| go_gin | 3 | 2,000 | $0.09 |
| ruby_rails | 3 | 1,500 | $0.07 |
| sql_tsql | 3 | 1,000 | $0.04 |
| sql_sqlite | 3 | 600 | $0.03 |
| swift_ios | 4 | 2,000 | $0.09 |
| kotlin_android | 4 | 2,000 | $0.09 |
| dart_flutter | 4 | 1,500 | $0.07 |
| rust_axum | 5 | 2,500 | $0.11 |
| cpp_modern | 5 | 2,000 | $0.09 |
| TOTAL | — | 36,800 | ~$2.85 |


## 5.4 Training Quality Requirements

- Every INTL construct in §2.3 must appear in at least 50 training pairs per adapter.
- PARALLEL, FALLBACK, and TRANSACTION constructs must appear in at least 100 pairs each (harder to learn).
- PATCH pairs must cover all INTL construct types as patch targets.
- No duplicate INTL blocks across train/validation split.
- Validation set: 200 held-out pairs per adapter, never seen during training.
- Minimum output quality: compiled outputs must pass the validation checks in §3.6 before inclusion in dataset.

## 5.5 Training Hyperparameters


| Parameter | Value |
| --- | --- |
| Base model | Qwen/Qwen2.5-Coder-3B-Instruct |
| Quantisation (training) | 4-bit NF4 QLoRA |
| LoRA rank (r) | 64 |
| LoRA alpha | 128 |
| LoRA dropout | 0.05 |
| Target modules | q_proj, k_proj, v_proj, o_proj, gate_proj, up_proj, down_proj |
| Learning rate | 2e-4 with cosine warmup (5% warmup ratio) |
| Batch size (per device) | 4 |
| Gradient accumulation | 4 (effective batch = 16) |
| Epochs | 3 |
| Max sequence length | 2048 tokens |
| Training hardware | Vast.ai RTX 4090 24GB @ ~$0.32/hr |
| Training time (per adapter) | ~25 minutes |



# Part 6 — Testing Requirements


## 6.1 Test Pipeline Stages

The testing pipeline runs after every compilation. It is the quality gate before output is written to the semantic index.

| Stage | Test Type | Pass Criteria |
| --- | --- | --- |
| T1 — Syntax | Tree-sitter parse of output | Zero parse errors |
| T2 — Sentinel | Regex match for INTL:BEGIN and INTL:END | Both sentinels present with correct ID |
| T3 — Preconditions | Check each PRECONDITION maps to a guard in output | All guards present |
| T4 — Postconditions | Check each POSTCONDITION maps to assertion/return constraint | All assertions present |
| T5 — Side effects | MUTATES → write op present. OBSERVABLE → log call present. | All side effects accounted for |
| T6 — Types | Return type matches TYPE declaration if one exists | Type compatible |
| T7 — No placeholders | Regex scan for TODO, FIXME, pass, unimplemented!() | Zero occurrences |
| T8 — Execution (Phase 1+) | Run compiled function against test fixtures | No runtime errors |


## 6.2 Acceptance Thresholds


| Target Group | Required Pass Rate (T1-T7) |
| --- | --- |
| SQL, HTML, CSS | >= 95% on validation set |
| Python, TypeScript, PHP, Go, Ruby | >= 90% on validation set |
| Java, C#, Swift, Kotlin, Dart | >= 87% on validation set |
| Rust, C++ | >= 80% on validation set (remainder handled by escalation) |

Pass rate is measured on the 200-pair validation set for each adapter. If an adapter does not meet threshold, training is repeated with an expanded dataset before deployment.

## 6.3 Escalation Rate Targets


| Target Group | Acceptable Escalation Rate |
| --- | --- |
| SQL, HTML, CSS | < 5% of production compilations |
| Python, TypeScript, PHP, Go, Ruby | < 12% of production compilations |
| Java, C#, Swift, Kotlin, Dart | < 15% of production compilations |
| Rust, C++ | < 20% of production compilations |



# Part 7 — Versioning and Change Protocol


## 7.1 Specification Versioning

This document follows semantic versioning. Any change to the construct vocabulary in §2.3 that removes or renames a construct is a MAJOR version bump and requires retraining affected adapters. New constructs are MINOR bumps. Clarifications and examples are PATCH bumps.

| Version | Changes |
| --- | --- |
| 0.1 (current) | Initial specification. 24 constructs. 24 adapters. 3B-only strategy. |
| 0.2 (planned) | Add RETRY construct. Add GraphQL profile. Expand mobile target idioms. |
| 1.0 (target) | Stable construct vocabulary. Full test coverage. All 24 adapters validated. |


## 7.2 Adding a New Target Language

- Add profile identifier to ADAPTER_MAP in the LoRA router.
- Document target-language idiom mappings in §4 of this spec.
- Generate training pairs: minimum 1,500 pairs covering all constructs.
- Train adapter on Vast.ai using standard hyperparameters (§5.5).
- Validate against 200-pair held-out set. Must meet threshold for that complexity tier.
- Push adapter to HuggingFace intl-adapters repo.
- Update OpenClaw workspace configs/adapters.json with new phase entry.

## 7.3 Modifying an Existing Construct

- Update §2 construct definition and example.
- Update §4 target-language output requirements for all affected adapters.
- Generate delta training pairs covering the changed behaviour (minimum 100 pairs per affected adapter).
- Fine-tune affected adapters (not full retrain — continue from checkpoint).
- Re-validate against full 200-pair set.
- Bump minor version number.

END OF SPECIFICATION
INTL Language — Version 0.1 — February 2026